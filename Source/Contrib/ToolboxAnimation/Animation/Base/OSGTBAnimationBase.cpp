/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: David Kabala (djkabala@gmail.com)                                *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class TBAnimation!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#include "OSGConfig.h"



#include "OSGTBAnimationEventSource.h"  // EventSource Class

#include "OSGTBAnimationBase.h"
#include "OSGTBAnimation.h"

#include <boost/bind.hpp>

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::TBAnimation
    \brief Abstract interface for controlling and applying the result of an
    #OSG::Animator to some object

    To use an animation, first create a concrete instance that
    inherits from Animation.  The animation can be started using the start()
    method.  Updating the animation can be done using the update() method, or
    preferably by attaching an UpdateEvent producer using the
    attachUpdateProducer() method.<br>

    Classes that inherit from Animation must implement the public
    getUnclippedLength() and protected internalUpdate() methods.  internalUpdate() is
    responsible for applying the result of an #OSG::Animator to some object.  The
    concrete class can define what object to apply to.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var Int32           TBAnimationBase::_sfCycling
    
*/

/*! \var Real32          TBAnimationBase::_sfScale
    
*/

/*! \var Real32          TBAnimationBase::_sfOffset
    
*/

/*! \var Real32          TBAnimationBase::_sfSpan
    
*/

/*! \var Real32          TBAnimationBase::_sfCycles
    
*/

/*! \var TBAnimationEventSource * TBAnimationBase::_sfEventSource
    
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<TBAnimation *, nsOSG>::_type(
    "TBAnimationPtr", 
    "AttachmentContainerPtr", 
    TBAnimation::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(TBAnimation *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           TBAnimation *,
                           nsOSG);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           TBAnimation *,
                           nsOSG);

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void TBAnimationBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "Cycling",
        "",
        CyclingFieldId, CyclingFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TBAnimation::editHandleCycling),
        static_cast<FieldGetMethodSig >(&TBAnimation::getHandleCycling));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "Scale",
        "",
        ScaleFieldId, ScaleFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TBAnimation::editHandleScale),
        static_cast<FieldGetMethodSig >(&TBAnimation::getHandleScale));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "Offset",
        "",
        OffsetFieldId, OffsetFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TBAnimation::editHandleOffset),
        static_cast<FieldGetMethodSig >(&TBAnimation::getHandleOffset));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "Span",
        "",
        SpanFieldId, SpanFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TBAnimation::editHandleSpan),
        static_cast<FieldGetMethodSig >(&TBAnimation::getHandleSpan));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "Cycles",
        "",
        CyclesFieldId, CyclesFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TBAnimation::editHandleCycles),
        static_cast<FieldGetMethodSig >(&TBAnimation::getHandleCycles));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecTBAnimationEventSourcePtr::Description(
        SFUnrecTBAnimationEventSourcePtr::getClassType(),
        "EventSource",
        "",
        EventSourceFieldId, EventSourceFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TBAnimation::editHandleEventSource),
        static_cast<FieldGetMethodSig >(&TBAnimation::getHandleEventSource));

    oType.addInitialDesc(pDesc);
}


TBAnimationBase::TypeObject TBAnimationBase::_type(
    TBAnimationBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    NULL,
    TBAnimation::initMethod,
    TBAnimation::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&TBAnimation::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"TBAnimation\"\n"
    "    parent=\"AttachmentContainer\"\n"
    "    library=\"ContribToolboxAnimation\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"abstract\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    isNodeCore=\"false\"\n"
    "    authors=\"David Kabala (djkabala@gmail.com)                             \"\n"
    ">\n"
    "\\brief Abstract interface for controlling and applying the result of an\n"
    "#OSG::Animator to some object\n"
    "\n"
    "To use an animation, first create a concrete instance that\n"
    "inherits from Animation.  The animation can be started using the start()\n"
    "method.  Updating the animation can be done using the update() method, or\n"
    "preferably by attaching an UpdateEvent producer using the\n"
    "attachUpdateProducer() method.&lt;br&gt;\n"
    "\n"
    "Classes that inherit from Animation must implement the public\n"
    "getUnclippedLength() and protected internalUpdate() methods.  internalUpdate() is\n"
    "responsible for applying the result of an #OSG::Animator to some object.  The\n"
    "concrete class can define what object to apply to.\n"
    "    <Field\n"
    "        name=\"Cycling\"\n"
    "        type=\"Int32\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"-1\"\n"
    "    >\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"Scale\"\n"
    "        type=\"Real32\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"1.0\"\n"
    "    >\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"Offset\"\n"
    "        type=\"Real32\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.0\"\n"
    "    >\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"Span\"\n"
    "        type=\"Real32\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"-1.0\"\n"
    "    >\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"Cycles\"\n"
    "        type=\"Real32\"\n"
    "        category=\"data\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "    >\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"EventSource\"\n"
    "        type=\"TBAnimationEventSource\"\n"
    "        category=\"pointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"NULL\"\n"
    "    >\n"
    "    </Field>\t\n"
    "<!--\n"
    "    <ProducedEvent\n"
    "        name=\"AnimationStarted\"\n"
    "        detailsType=\"AnimationEventDetails\"\n"
    "        consumable=\"true\"\n"
    "    >\n"
    "    </ProducedEvent>\n"
    "    <ProducedEvent\n"
    "        name=\"AnimationStopped\"\n"
    "        detailsType=\"AnimationEventDetails\"\n"
    "        consumable=\"true\"\n"
    "    >\n"
    "    </ProducedEvent>\n"
    "    <ProducedEvent\n"
    "        name=\"AnimationPaused\"\n"
    "        detailsType=\"AnimationEventDetails\"\n"
    "        consumable=\"true\"\n"
    "    >\n"
    "    </ProducedEvent>\n"
    "    <ProducedEvent\n"
    "        name=\"AnimationUnpaused\"\n"
    "        detailsType=\"AnimationEventDetails\"\n"
    "        consumable=\"true\"\n"
    "    >\n"
    "    </ProducedEvent>\n"
    "    <ProducedEvent\n"
    "        name=\"AnimationEnded\"\n"
    "        detailsType=\"AnimationEventDetails\"\n"
    "        consumable=\"true\"\n"
    "    >\n"
    "    </ProducedEvent>\n"
    "    <ProducedEvent\n"
    "        name=\"AnimationCycled\"\n"
    "        detailsType=\"AnimationEventDetails\"\n"
    "        consumable=\"true\"\n"
    "    >\n"
    "    </ProducedEvent>\n"
    "-->\n"
    "</FieldContainer>\n",
    "\\brief Abstract interface for controlling and applying the result of an\n"
    "#OSG::Animator to some object\n"
    "\n"
    "To use an animation, first create a concrete instance that\n"
    "inherits from Animation.  The animation can be started using the start()\n"
    "method.  Updating the animation can be done using the update() method, or\n"
    "preferably by attaching an UpdateEvent producer using the\n"
    "attachUpdateProducer() method.<br>\n"
    "\n"
    "Classes that inherit from Animation must implement the public\n"
    "getUnclippedLength() and protected internalUpdate() methods.  internalUpdate() is\n"
    "responsible for applying the result of an #OSG::Animator to some object.  The\n"
    "concrete class can define what object to apply to.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &TBAnimationBase::getType(void)
{
    return _type;
}

const FieldContainerType &TBAnimationBase::getType(void) const
{
    return _type;
}

UInt32 TBAnimationBase::getContainerSize(void) const
{
    return sizeof(TBAnimation);
}

/*------------------------- decorator get ------------------------------*/


SFInt32 *TBAnimationBase::editSFCycling(void)
{
    editSField(CyclingFieldMask);

    return &_sfCycling;
}

const SFInt32 *TBAnimationBase::getSFCycling(void) const
{
    return &_sfCycling;
}


SFReal32 *TBAnimationBase::editSFScale(void)
{
    editSField(ScaleFieldMask);

    return &_sfScale;
}

const SFReal32 *TBAnimationBase::getSFScale(void) const
{
    return &_sfScale;
}


SFReal32 *TBAnimationBase::editSFOffset(void)
{
    editSField(OffsetFieldMask);

    return &_sfOffset;
}

const SFReal32 *TBAnimationBase::getSFOffset(void) const
{
    return &_sfOffset;
}


SFReal32 *TBAnimationBase::editSFSpan(void)
{
    editSField(SpanFieldMask);

    return &_sfSpan;
}

const SFReal32 *TBAnimationBase::getSFSpan(void) const
{
    return &_sfSpan;
}


SFReal32 *TBAnimationBase::editSFCycles(void)
{
    editSField(CyclesFieldMask);

    return &_sfCycles;
}

const SFReal32 *TBAnimationBase::getSFCycles(void) const
{
    return &_sfCycles;
}


//! Get the TBAnimation::_sfEventSource field.
const SFUnrecTBAnimationEventSourcePtr *TBAnimationBase::getSFEventSource(void) const
{
    return &_sfEventSource;
}

SFUnrecTBAnimationEventSourcePtr *TBAnimationBase::editSFEventSource    (void)
{
    editSField(EventSourceFieldMask);

    return &_sfEventSource;
}





/*------------------------------ access -----------------------------------*/

SizeT TBAnimationBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (CyclingFieldMask & whichField))
    {
        returnValue += _sfCycling.getBinSize();
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        returnValue += _sfScale.getBinSize();
    }
    if(FieldBits::NoField != (OffsetFieldMask & whichField))
    {
        returnValue += _sfOffset.getBinSize();
    }
    if(FieldBits::NoField != (SpanFieldMask & whichField))
    {
        returnValue += _sfSpan.getBinSize();
    }
    if(FieldBits::NoField != (CyclesFieldMask & whichField))
    {
        returnValue += _sfCycles.getBinSize();
    }
    if(FieldBits::NoField != (EventSourceFieldMask & whichField))
    {
        returnValue += _sfEventSource.getBinSize();
    }

    return returnValue;
}

void TBAnimationBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (CyclingFieldMask & whichField))
    {
        _sfCycling.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OffsetFieldMask & whichField))
    {
        _sfOffset.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SpanFieldMask & whichField))
    {
        _sfSpan.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CyclesFieldMask & whichField))
    {
        _sfCycles.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EventSourceFieldMask & whichField))
    {
        _sfEventSource.copyToBin(pMem);
    }
}

void TBAnimationBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (CyclingFieldMask & whichField))
    {
        editSField(CyclingFieldMask);
        _sfCycling.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        editSField(ScaleFieldMask);
        _sfScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OffsetFieldMask & whichField))
    {
        editSField(OffsetFieldMask);
        _sfOffset.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SpanFieldMask & whichField))
    {
        editSField(SpanFieldMask);
        _sfSpan.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CyclesFieldMask & whichField))
    {
        editSField(CyclesFieldMask);
        _sfCycles.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EventSourceFieldMask & whichField))
    {
        editSField(EventSourceFieldMask);
        _sfEventSource.copyFromBin(pMem);
    }
}




/*------------------------- constructors ----------------------------------*/

TBAnimationBase::TBAnimationBase(void) :
    Inherited(),
    _sfCycling                (Int32(-1)),
    _sfScale                  (Real32(1.0)),
    _sfOffset                 (Real32(0.0)),
    _sfSpan                   (Real32(-1.0)),
    _sfCycles                 (Real32(0)),
    _sfEventSource            (NULL)
{
}

TBAnimationBase::TBAnimationBase(const TBAnimationBase &source) :
    Inherited(source),
    _sfCycling                (source._sfCycling                ),
    _sfScale                  (source._sfScale                  ),
    _sfOffset                 (source._sfOffset                 ),
    _sfSpan                   (source._sfSpan                   ),
    _sfCycles                 (source._sfCycles                 ),
    _sfEventSource            (NULL)
{
}


/*-------------------------- destructors ----------------------------------*/

TBAnimationBase::~TBAnimationBase(void)
{
}

void TBAnimationBase::onCreate(const TBAnimation *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        TBAnimation *pThis = static_cast<TBAnimation *>(this);

        pThis->setEventSource(source->getEventSource());
    }
}

GetFieldHandlePtr TBAnimationBase::getHandleCycling         (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfCycling,
             this->getType().getFieldDesc(CyclingFieldId),
             const_cast<TBAnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TBAnimationBase::editHandleCycling        (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfCycling,
             this->getType().getFieldDesc(CyclingFieldId),
             this));


    editSField(CyclingFieldMask);

    return returnValue;
}

GetFieldHandlePtr TBAnimationBase::getHandleScale           (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfScale,
             this->getType().getFieldDesc(ScaleFieldId),
             const_cast<TBAnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TBAnimationBase::editHandleScale          (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfScale,
             this->getType().getFieldDesc(ScaleFieldId),
             this));


    editSField(ScaleFieldMask);

    return returnValue;
}

GetFieldHandlePtr TBAnimationBase::getHandleOffset          (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOffset,
             this->getType().getFieldDesc(OffsetFieldId),
             const_cast<TBAnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TBAnimationBase::editHandleOffset         (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOffset,
             this->getType().getFieldDesc(OffsetFieldId),
             this));


    editSField(OffsetFieldMask);

    return returnValue;
}

GetFieldHandlePtr TBAnimationBase::getHandleSpan            (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfSpan,
             this->getType().getFieldDesc(SpanFieldId),
             const_cast<TBAnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TBAnimationBase::editHandleSpan           (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfSpan,
             this->getType().getFieldDesc(SpanFieldId),
             this));


    editSField(SpanFieldMask);

    return returnValue;
}

GetFieldHandlePtr TBAnimationBase::getHandleCycles          (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfCycles,
             this->getType().getFieldDesc(CyclesFieldId),
             const_cast<TBAnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TBAnimationBase::editHandleCycles         (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfCycles,
             this->getType().getFieldDesc(CyclesFieldId),
             this));


    editSField(CyclesFieldMask);

    return returnValue;
}

GetFieldHandlePtr TBAnimationBase::getHandleEventSource     (void) const
{
    SFUnrecTBAnimationEventSourcePtr::GetHandlePtr returnValue(
        new  SFUnrecTBAnimationEventSourcePtr::GetHandle(
             &_sfEventSource,
             this->getType().getFieldDesc(EventSourceFieldId),
             const_cast<TBAnimationBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TBAnimationBase::editHandleEventSource    (void)
{
    SFUnrecTBAnimationEventSourcePtr::EditHandlePtr returnValue(
        new  SFUnrecTBAnimationEventSourcePtr::EditHandle(
             &_sfEventSource,
             this->getType().getFieldDesc(EventSourceFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&TBAnimation::setEventSource,
                    static_cast<TBAnimation *>(this), _1));

    editSField(EventSourceFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void TBAnimationBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    TBAnimation *pThis = static_cast<TBAnimation *>(this);

    pThis->execSync(static_cast<TBAnimation *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif



void TBAnimationBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<TBAnimation *>(this)->setEventSource(NULL);


}


OSG_END_NAMESPACE
